<?xml version="1.0" encoding="UTF-8"?>
<document>
  <properties>
    <title>Introduction to as3commons-async</title>
    <author email="scab@dds.nl">Roland Zwaga</author>
  </properties>

  <body>
    <section name="Introduction">
    <p>One of the most prevalent actions in any Flash or Flex application is: Get stuff from the server back-end. Be it calling a remote object, loading a sub-application, module or resource file, all of these actions have one thing in common: They are asynchronous.</p>
    <p>The Flex framework and Flash player seem to use different kinds of asynchronous patterns for different kinds of retrieval. There's the responder method, the event based method (all be it with an optional progress reporting mechanism), calls to a singleton that returns an IEventDispatcher instance or some other interface, etc.<br/>
    AS3Commons-async aims to facilitate a common interface for these different patterns in order to make using and combining them a little easier. The provided interfaces and base classes will give a developer the opportunity to easily write her or his own logic.</p>
    </section>
    <section name="Concepts">
    	<p>AS3Commons-async, broadly speaking, has four concepts:</p>
		<ul>
			<li>Operation: An asynchronous action.</li>
			<li>Command: An action with deferred execution, can be asynhronous.</li>
			<li>Service: A collection of related operations.</li>
			<li>Task: A collection of commands that are executed using a control flow.</li>
		</ul>
    </section>
    <section name="Operations">
    <p>An operation represents any kind of asynchronous action and is described by the IOperation interface:</p>
    <div class="source"><pre>public interface IOperation extends IEventDispatcher {

	function get result():*;

	function get error():*;

	function get timeout():int;

	function set timeout(value:int):void;

	function addCompleteListener(listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void;

	function addErrorListener(listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void;

	function addTimeoutListener(listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void;

	function removeCompleteListener(listener:Function, useCapture:Boolean = false):void;

	function removeErrorListener(listener:Function, useCapture:Boolean = false):void;

	function removeTimeoutListener(listener:Function, useCapture:Boolean = false):void;

}</pre></div>
	<subsection name="Long running operations">
	<p>Operations that take long amounts of time to complete, such as downloading files benefit from being able to notify the user of their progress. Typically a progress bar could display this. For these types of operations there is the IProgressOperation interface, which is a simple extension of IOperation:</p>
	<div class="source"><pre>public interface IProgressOperation extends IOperation {

 function get progress():uint;

 function get total():uint;

 function addProgressListener(listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void;

 function removeProgressListener(listener:Function, useCapture:Boolean = false):void;
}</pre></div>
	</subsection>
	<subsection name="Operation queues">
	<p>In some cases a collection of IOperations need to be run at once, yet each individual OperationEvent.COMPLETE event doesn't need to be listened for. All that is important is that all of the IOperations are completed successfully. For this situation the OperationQueue class can help out. A simple usage of this class might be like this:</p>
	<div class="source"><pre>var queue:OperationQueue = new OperationQueue();
queue.addCompleteListener(handleQueueComplete);
queue.addOperation(new FirstOperation());
queue.addOperation(new SecondOperation());
queue.addOperation(new ThirdOperation());
queue.addOperation(new FourthOperation());</pre></div>
	<p>And that's all, upon adding the operations the queue immediately starts running. So after all four operations have completed the specified handleQueueComplete method will be invoked and the application can go on about its business.</p>
	</subsection>
    </section>
    <section name="Commands">
    	<p>A command is any kind of action whose execution is deferred. Only after invoking the command's execute() method will the action do its work. The basic ICommand interface is very modest:</p>
    	<div class="source"><pre>public interface ICommand {

 function execute():*;

}</pre></div>
	<p>This represents a synchronous command, so the logic that is executed by an implementation will be available immediately after the call to the execute() method, and typically be returned in the execute()'s result.
More interesting is the IAsyncCommand interface which is actually just a combination of the ICommand and IOperation interfaces:</p>
	<div class="source"><pre>public interface IAsyncCommand extends ICommand, IOperation {

}</pre></div>
	<p>This interface allows a command to be constructed that will execute an asynchronous action. So contrary to an IOperation instance an IAsyncCommand can be created, but its logic executed at a later moment.
Because the command is asynchronous the result property will be null directly after the execute() method has been called, also the result of the execute() method will be either null or undefined. To retrieve the result of the IAsyncCommand, add listeners for the OperationEvent.COMPLETE and OperationEvent.ERROR events.</p>
	<subsection name="Composite commands">
	<p>Just like IOperations its very well possible that a collection of ICommands or IAsyncCommands (or a mixed collection of them) needs to be executed. For this scenario the CompositeCommand class is ideal. It allows a list of ICommands to be executed in parallel or sequence. The CompositeCommand class is an implementation of the ICompositeCommand interface:</p>
	<div class="source"><pre>public interface ICompositeCommand extends ICommand, IOperation {

	function addCommand(command:ICommand):ICompositeCommand;

	function addOperation(operationClass:Class, ... constructorArgs):ICompositeCommand;

	function get numCommands():uint;

	function get kind():CompositeCommandKind;
}</pre></div>
	<p>Note the addOperation() method, a Class (which implements IOperation) can be passed in along with a number of optional arguments. This IOperation will be wrapped in a GenericOperationCommand instance which can will create the operation class
	in its execute() method.<br/>
	A simple example of the usage of a CompositeCommand instance would be like this:</p>
	<div class="source"><pre>var compositeCommand:CompositeCommand = new CompositeCommand(ComposeiteCommandKind.SEQUENCE);
compositeCommand.addCommand(new FirstCommand());
compositeCommand.addCommand(new SecondCommand());
compositeCommand.addCommand(new ThirdCommand());
compositeCommand.addCommand(new FourthCommand());
compositeCommand.addCompleteListener(handleCompositeCommandComplete);
compositeCommand.addErrorListener(handleCompositeCommandError);
compositeCommand.execute();</pre></div>
	<p>This will execute the FirstCommand instance, wait for it to complete, execute the SecondCommand instance, wait for it to complete, etc.
If all commands complete successfully the specified handleCompositeCommandComplete method will be invoked, if an error occurs the handleCompositeCommandError method is invoked instead.</p>
	<blockquote>The failOnFault property determines whether the CompositeCommand instance should stop executing its list of commands in the case of an error. Default this property is set to false. So all commands will be executed no matter what their result is.</blockquote>
	</subsection>
	<subsection name="GenericOperationCommand">
	<p>Having an ICommand implementation of each and every IOperation in an application isn't always practical, therefore the GenericOperationCommand might help out a little. The GenericOperationCommand is nothing more than a simple IAsyncCommand wrapper. All that a GenericOperationCommand needs is the Class of an arbitrary IOperation and an optional list of constructor arguments. For example, here is how the LoadURLOperation would be wrapped:</p>
	<div class="source"><pre>var genericOperationCommand = new GenericOperationCommand(LoadURLOperation, 'http://www.mydomain.com/index.html');
genericOperationCommand.addCompleteHandler(operationCompleteHandler);
genericOperationCommand.execute();</pre></div>
	</subsection>
    </section>
  </body>
</document>
